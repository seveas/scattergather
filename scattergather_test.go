// Code generated by go2go; DO NOT EDIT.


//line scattergather_test.go2:1
package scattergather

//line scattergather_test.go2:1
import (
//line scattergather_test.go2:1
 "context"
//line scattergather_test.go2:1
 "errors"
//line scattergather_test.go2:1
 "fmt"
//line scattergather_test.go2:1
 "golang.org/x/sync/semaphore"
//line scattergather_test.go2:1
 "runtime"
//line scattergather_test.go2:1
 "sort"
//line scattergather_test.go2:1
 "sync"
//line scattergather_test.go2:1
 "testing"
//line scattergather_test.go2:1
)

//line scattergather_test.go2:10
func TestBasic(t *testing.T) {
	sg := new(instantiate୦୦ScatterGather୦int)
	ctx := context.Background()
	args := make([]int, cap(sg.resultChan)+10)
	expected := make([]int, cap(args))
	for i, _ := range args {
		j := i
		args[i] = i
		expected[i] = i * i
		sg.Run(func() (int, error) { return j * j, nil }, ctx)
	}
	result, _ := sg.Wait()
	sort.Ints(result)
	fmt.Println(args)
	fmt.Println(expected)
	fmt.Println(result)
}

//line scattergather_test.go2:26
type instantiate୦୦ScatterGather୦int struct {
//line scattergather.go2:14
 waitGroup *sync.WaitGroup
				results   []int

//line scattergather.go2:16
 errors     *ScatteredError
				resultChan chan instantiate୦୦scatterResult୦int
				doneChan   chan interface{}
				initOnce   sync.Once
				gatherOnce sync.Once
				semaphore  *semaphore.Weighted
}

//line scattergather.go2:29
func (sg *instantiate୦୦ScatterGather୦int,) init(parallel int64) {
	sg.initOnce.Do(func() {
		if parallel == 0 {
			parallel = int64(runtime.GOMAXPROCS(0))
		}
		sg.waitGroup = &sync.WaitGroup{}
		sg.results = make([]int, 0)
		sg.errors = &ScatteredError{}
		sg.errors.Errors = make([]error, 0)
		sg.resultChan = make(chan instantiate୦୦scatterResult୦int, 10)
		sg.doneChan = make(chan interface{})
		sg.semaphore = semaphore.NewWeighted(parallel)
	})
}

func (sg *instantiate୦୦ScatterGather୦int,) gather() {
	sg.gatherOnce.Do(func() {
		go sg.gatherer()
	})
}

func (sg *instantiate୦୦ScatterGather୦int,) gatherer() {
	for res := range sg.resultChan {
		sg.results = append(sg.results, res.val)
		if res.err != nil {
			sg.errors.AddError(res.err)
		}
	}
	close(sg.doneChan)
}

//line scattergather.go2:63
func (sg *instantiate୦୦ScatterGather୦int,) Run(callable func() (int,

//line scattergather.go2:63
 error), ctx context.Context) {
	sg.init(0)
	sg.gather()
	sg.waitGroup.Add(1)
	go func() {
		defer sg.waitGroup.Done()
		if err := sg.semaphore.Acquire(ctx, 1); err != nil {
			sg.resultChan <- instantiate୦୦scatterResult୦int{err: err}
		}
		defer sg.semaphore.Release(1)
		ret, err := callable()
		sg.resultChan <- instantiate୦୦scatterResult୦int{val: ret, err: err}
	}()
}

//line scattergather.go2:82
func (sg *instantiate୦୦ScatterGather୦int,) Wait() ([]int,

//line scattergather.go2:82
 error) {
	sg.waitGroup.Wait()
	close(sg.resultChan)
	<-sg.doneChan
	if !sg.errors.HasErrors() {
		return sg.results, nil
	}
	return sg.results, sg.errors
}

//line scattergather.go2:90
type instantiate୦୦scatterResult୦int struct {
//line scattergather.go2:25
 val int

//line scattergather.go2:26
 err error
}

//line scattergather.go2:27
var _ = context.Background
//line scattergather.go2:27
var _ = errors.As
//line scattergather.go2:27
var _ = fmt.Errorf
//line scattergather.go2:27
var _ = semaphore.NewWeighted
//line scattergather.go2:27
var _ = runtime.BlockProfile

//line scattergather.go2:27
type _ sort.Float64Slice
//line scattergather.go2:27
type _ sync.Cond

//line scattergather.go2:27
var _ = testing.AllocsPerRun
